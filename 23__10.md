# Cпецификаторы(продолжение)

До стандарта с++11 auto входил в спецификаторы класса памяти т.е.указывал на длительность хранения переменной в памяти

''''c++
float f = 4.5
auto float d = 5.5
''''''

До стандарта с++11 выражения выше были эквивалентны - они показывали что обе переменные должны храниться в памяти столько, сколько решит компилятор

Более известный спецификатор - static;

```c++
void foo() {
int a = 5;
static int b = 5;
a += 5;
b += 5;
cout « a « ", " « b « std::endl;
}

int main() {
foo(); // 10, 10
foo(); // 10, 15
foo(); // 10, 20
foo(); // 10, 25

return 0;
}
```

Кроме этого есть спецификатор extern, который указывает на статическую глобальную переменную, обращаться к которой могут несколько файлов программы

Например, если у нас в файле "header.h" определено "extern float d = 5.5;", то мы може обратиться к d из другого файла, например, "main.cpp".



# Структура программы на С++

## Базовая часть программы - функция main
При выполнении консольного приложения с++ операционная система при запуске приложения передает управление функции с идентификатором "main()".

Функцию "main()" нелльзя вызывать из других функций программы.

"main()" в базовом виде не принимает никаких аргументов необходимых для ее функционирования

По стандарту С++ функция "main()" должна возвращать целочисленный код, определяющий успешно ли завершилась программа этот код обрабатывается операционной системой.

Поэтому "main()" всегда указывается как функция с целым возвращаемым значением

```c++
int main() {

return 0; // код 0 обозначает что программа отработала успешно
}
```
Если возвращается иной код или вообще не возвращается никакого кода, то система считает такое поведение аварийным остановом программы

Базовая программа на с++ может выглядеть так:

```c++
int main() { //определение главной функции
std::cout « "Hello world!"; // в теле главной функции пишем команду вывода сообщения в стандартный поток ввода/вывода (консоль)

return 0; // Возвращаем код, что программа выполнена успешно
}
```
Если запускаете через командную строку, то она может закрыться сразу после завершения программы т.е.сообщение вы не увидите.Во избежание этого до return 0 нужно добавить system("pause")

## Общий вид программы на с++

```c+ +
#include <iostream>//подключение необходимых библиотек и файлов (директивы препроцессора)
using namespace std;// указание на используемое пространство имён
//вы можете делать указание на нужное пространство имен (и это поощрается в реальной работе) через двойное двоеточие
// std::cout

// объявление и/или инициализация глобальных переменных (доступны всему, что описано в файле)
int b;
int c = 0;

//определение функций классов и т.п.
float a() {

//что-то делаем
return 0.0;
}
// если это файл, который должен быть точкой входа в программу (в простых программах - единственный файл) необходимо определить функцию main()
int main() {
//что-то делаем
return 0; // говорим, что все сделали и все ок
}
```
##Пространство имен
Основное назначение имён - минимизация возможости конфликтов из-за совпадения имен, функций, классов, переменных и т.п.

```c++
namespace MyNamespace
{
int a = 0;
int b = 2;
int c = -6;
}
//using namespace MyNamespace

int() {
MyNamespace::a += MyNamespace::b;
}
```

Новые переменные, функции и т.д.определенные в пространстве имен должны быть описаны заранее.
Добавление новых сущностей в существующее пространство имен внутри программы невозможно


## Основные операнды
Операнд - служебный элемен синтаксиса языка, который определяет некоторую арифметическую или логическую операция.

Большинство операций с переменными осуществляются через арифметические операнды.

Список арифметических операндов бинарных операций(в порядке уменьшения их приоритета)
- "*" - операнд умножения
- "/" - операнд деления
- "+" - операнд сложения
- "-" - операнд вычитания
- "%" - операнд получения остатка от целочисленного деления

Основные операнды унарных операций(в порядкеуменьшения приоритета)
- "++" - инкремент, операнд инкрементирования, т.е.увеличения на 1
- "--" - декремент, операнд декрементирования, т.е уменьшения на 1
- "-" - операнд изменения знака

Инкрементация и Декрементация в С++ существуют префиксные и постфиксные

```C+ +
int a = 5;

a++ //постфиксная
++a //префиксная
```

В случае постфиксной инкрементации сначала происходит вычислние операций идущих левее или выше постфиксного инкремента
и после чего и только после этого происходит увеличение значения переменной на 1

В случае префиксной инкрементацией сначала происходит увеличение на 1, после этого и только после этого выполняются иные сопутствующие операии в выражении.

```C+ +
int a = 5;
int b = 6;
int c = 0

c = a * ++b
//c = 35
```

```C++
int a = 5;
int b = 6;
int c = 0

c = a * b++
// c = 30, но b = 7
```

Все бинарные арифметические операнды могут быть объедины с операцией присваивания
- "*" - операнд умножения с присваиванием
- "/" - операнд деления с присваиванием
- "+" - операнд сложения с присваиванием
- "-" - операнд вычитания с присваиванием
- "%" - операнд получения остатка от целочисленного деления с присваиванием

Каждая такая операция - сокращенная запись:

а = а * b; // то же что и а *= b;

# Процедура сбора и отладки программы на С++
# Препроцессорное преобразование текста (в текстовом редакторе)

Преобразование текста исходного кода в основу для набораа машинных кодов. Включает следующие стадии.

1. Перекодирование всех системных обозначений в стандартные коды
2. Размещение в тексте каждой отдельной строки директив и лексем препроцессора, а так же замена комментариев символом пустого промежутка
3. Выполнение директив препроцессора и макроподстановок - замена значений параметризированным текстом.
Препроцессор построчно сканирует текст исходного кода в поиске строк наинающихся с решетки.
Каждая такая строка интерпритируется как директива, которые определяют, как нужно далее преобразовать текст
4. Замена идентификаторов заранее подготовленными последовательностями символов.
5. Включение в программу текстов из подключенных файлов.
6. Escape-последовательности (экранированные последовательности) в символьных константах и переменных (например, '\n') заменяются на соответствующие числовые коды.
7. Каждая препроцессорная лексема преобразуется в лексему языка С++.

## Компиляция
Компиляция обрабатывает файлы исходного кода (С, сс, .срр, например) и создает объектные файлы проекта
На этапе компиляции еще не создается исполняемый файл.
Компилятор использует полученную на этапе препроцессинга заготовку для преобразования ее в набор машинных кодов соответствующей архитектуры исполнителя (т.е. процессора)

Число файлов компилятора совпадает с числом файлов исходного кода, они создаются как соответствующие входные данные.

Расширением файлом чаще всегго бывают .obj или .o

Каждый из файлов содержит последовательность машинных инструкций, эквивалентную исходному коду.
но на данном этапе запустить их все еще нельзя так как необходимо преобразовать в исполняемые файлы ОС

### Компановка

На данном этапе из набора объектных файлов создается единый исполняемый файл.

т.к. компилятор преобразует каждый файл независимо от других, то отсутствующие определения функций переменных и т.п. для него равны наличию этих определений в любом другом файле.
Он не проверяет, существует ли определение в принципе

Именно компоновщик изучает связи между файлами и пытается восстановить ссылки на функции, переменные и т.п., которые не указаны в отдельно взятом файле.

Этапы компеляции и компоновки разделены в целях снижения нагрузки и ускорения процесса сборки программы в больших проектах (например, с десятками файлов исходного кода,
каждый из которых может быть на сотни и тысячи строк), т.к. при сборке проекта необходимо будет перекомпилировать только измененные файлы,
а все остальные объектные файлы компоновщик может взять из предыдущих запусков компиляции

## Директивы препроцессора (ОБЗОР)
все директивы препроцессора начинаются с символа # и
занимают ровно одну строку, указанный символ должен быть первым символом строки.
Директива #include включает в программу содержимое указанного файла.

#include <some_file.h> // Файл лежит в числе стандартных (компилятор будет искать его в заранее заданных специальных директориях)
#include "my_header.h" // Файл пользовательский, ищем в операционной системе начиная с каталога, где лежит исходный код

#define - определяет неоторую константу препроцессора, причем она интерпритирует как определение либо выражение идущее сразу за директивой, либо содержимое файла

#ifndef AK_H
#define AK_H
// содержимое ak.h
#endif


## Условные директивы препроцессора
#if - проверка условия
#ifdef - проверка определенности идентификатора
#ifndef - проверка неопределенности идентификатора
#else - начало альтернативной ветки для #if
#endif - окончание условной директивы #if
#ifdef, #ifndef