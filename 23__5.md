# Разница между машинным словом и моделью данных
**Машинное слово ЦП** - физическое, железное ограничение на макс размер данных, которые процессор может оброботать за одну операцию. Машинное слово напрямую связано с архитектурными особенностями процессоров, с тем, как реализовать его <<железо>>

-2003-2004 год - Появление первых прцессоров с 64-бит машинным словами для пользователей( например, AMD Athelon 64 [Именно по этому архитектура 64 бит как расширение интоловской x86 называетч такжу amd64 наряду с более универсальным обозначением x86-64])

Современные процессоры повсевместно используют 64- битные слова чт даёт следующие диапозоны целых чисел:

1. Без знака - От 0 до 18.446.744.073.709.551.615 ((2^64)-1)
2. Со знаком - -(2^63)....(2^63)-1

Этот диапазон считается достаточным на современном этапе развития технологий более чем достаточным для всех вычислительных операций.

**Модель данных** - то, как различные стандарты описывают те или иные форматы(типпы) данных(целое число, символ, булево значение, вещественное число и тд). Модель данных может улучшать или увеличивать кол во бит которое отводиться для тех или иных типов, но ниеогда ни один тип не может превысить величину машинного слова.

Именно поэтому мы на 64- битных машинах с 64 бит моделями данных имеем 32 битное целое число.


## внутренние представление целого положительного числа N

При условии использнования к-разрядного машинного слова ИЛИ модели данных

1. Перевести N в двоичную систему счисления.
2. Полученный результат заполнить слева незначащими нулями до получения "К" разрядов
3. Выполнить групировку разрядов по октетам(8бит)
4. Расположить октеты в соответствии с порятком байт(LE/BE).
Минимально на требуються только 2 первых шага - так получается представление числа в общем виде. Шаги 3 и 4 дают вид числа в памят конкретной машины

Пример: Представить в памяти с порядком LE и моделью данных, где для целых чисел отведено 2 байта(16 бит) десятичное число 1607 на 32 битном ЦП

1. 11001000111 - 11 разярядов в двоичном представлении числа
2. 0000011001000111 - Дополняем до 16 разрядов (11+5) нулями слева
3. 0000011001000111 разбиваем на октеты(т.е. на байты) получается ровно 2 байта как того требует модель данных
4. 01000111 00000110 - распологаем байты в соответствии с порядком 'Little-endian', как требует архитектура, т.е. располагаем младший байт (содержащий младшие разряды) **левее** всего.


Пример 2:Получить десятичное число из его шестнадцатиричного представления в памяти. известно, что для целых чисел используется 4 байта, порядок - BE

Дана следующаяя запись 0x00 0x00 0x0A 0x58

1. 00000000 00000000 00001010 01011000
2. 1010 01011000 - убрали все нули
3. 101001011000(2) = (2648)(10)


## Внутреннее представление целого отрицательного числа -N 

При условии использнования к-разрядного машинного слова ИЛИ модели данных

1. Получить внутреннее представление целого положительного числа N в тех же k разрядах(по алгоритму выше). Важно использовать для этого BE  порядок т.е. не перемещать разряды!
2. получить обратный ход числа (заменяем 1 на 0 и 0 на 1)
3. К полученному числу добавить один 
4. Разбить на октеты и разположить байты в соответствии с нужным порядком.

Пример: 1607 

0000011001000111
00000110 01000111
11111001 10111000
11111001 10111000 + 1 = 11111001 10111001


2648 в порядке LE и шестнадцатиричном виде (для хранения используються 4 байта)

00000 0000 00001010 01011000
11111111  11111111 11110101 10101000
10101000 11110101 11111111 11111111
0xA8 0xFE 0xDC 0x55

0xFF 0xFF 0xDC 0x55
11111111 11111111 11011100 01010101 -1 = 11111111 11111110 11011100 01010100
00000000 00000001 00100011 10101011(2) = -74667 (10)


# ПРЕДСТАВЛЕНИЕ ВЕЩЕСТВЕННЫХ ЧИСЕЛ В ПАМЯТИ КОМПЬЮТОРА
 
 В данном формате могут быть представлены и целые и дробные числа
 
Как следствие целое число в формате целого числа('int') храниться в памяти иначе, чем тоже самое число, но в формате вещественного числа.

Вещественное число R= m*n^p, где: 
R - действительное число
m - мантиса числа,
n - основание сис счисления
p - порядок(степень)

25.324 - 2.5325 * 10^1 - 2532.4 * 10^-2 = 0.0025324 * 10^4 и т.д. - точка плавает в зависимости от выбранного ими порядка

Это означает:
 
 1. Мантисса должна удволетворять условию '0.1 <= m < 1' Т.е. мантисса меньше на 1 и первая означающая цифра всегда не ноль.

 > Это выбрано для того чтобы никак не требовалось хранить в памяти 0 целых и саму точку.
 > Например: 25.324 = 0.**2532** * 10^**2**
 2. В памяти должен храниться только порядок, т.к. основание системы счисления ПК всегда 2

 Под числа с плавающей точкой отводится обычно всё машинное слово или 1/2 машинного слова. В случае с 64-битными архитектурами это означает 4 байта и 8 байтов для хранения числа с плавующей точкой

 Что и как нужно хранить:
 1. Мантиссу
 2. Порядок
 3. Знак числа
 4. Знак порядка
 
 Возьмем для примера 4 байтовое число с плавающей точкой ('float')
 [0]{0000000} 00000000 00000000 00000000
 [0] - знаковый бит, если 0 то число положительное если 1 то число отрицательное.
 {0000000} - 7 бит т.е. мы можем записать код сюда от 0(10) до 127(10) / 0000000 ..... 1111111, что удобнее для хранения порядка. **машинный порядок**
 **Диапазон машинный порядков**
 - min машинный порядок (Mp) - 0000000(2)= 0(10)
 - max машинный порядок (Mp) - 1111111(2)= 127(10)
 **Диапазон математических порядков** = 128 шт
 Их делять на положительны
 диапазон математического порядка -64...+63
 
 Оставшиеся 3 байта(24 бита) - мантиса

## Математический и машинный порядок

Из за того что мы не можем хранить в битовом представлении отрицательный порядок, **машинный порядок смещён относительно математического и имеет только положительное значение**.

Смещение выбрано так, что минимальный математический порядок кодируется 0 в машинном порядке. Т.е. в 7 бит умещается 128 различных значений, включая 0. Чтобы представить равное число + и - математических порядков, мы делим это на 2(диапазон целых чисел)

Таким образом, мы получаем диапазон математического порядка -64...+63. Следовательно, мы можем выбирать смещение:

Mp=P+64, где Mp-машинный порядок, P- математический порядок

Так же формула в 2-й СС M(2)=P(2)+1000 000(2)
Перевод осуществляется как обычно через деление.

Смещение машинных порядков(относительно математических) в положительную область выбрана так что бы значение машинных порядков оказываються в положительной части числовой ОСИ 

# Внутренние представление вещественного числа R
 Используем 32 битный тип данных для записи чисел с плавающей точкой.
 
 1. Переводим *модуль* числа в двоичную СС с [24] значищими цифрами, дополняем нулями справо до 24 разрядов.
 2. Нормализовать двоичное число(см. формулу выше;0.1 <= m < 1)
 3. Найти машинный порядок по формуле M(2)=P(2)+1000 000(2)
 4. Учитывая исходный знак числа (т.е. корректно выставить значения знакового бита), вписать результат(машинный порядок и мантисса) в доступные 4 байта (или машинное слово)

Пример: Записать представление числа **250.1875**

 250.1875(10)-->11111010.0011(2)
 После добовляем до 24 цифр
 11111010.00110000 00000000
 0.111110100011000000000000(2)*10(2)^1000(2)
 *порядок P = числу разрядов в целой части числа* *1000(2)=8(10)*
 1001000(2)-машинный порядок

 [0]{1001000}11111010 00110000 00000000 -  Машинное представление числа 250.1875(10)

0xC9 0x81 0x10 0x00

11001001 10000001 00010000 00000000
[1]{1001001} 10000001 00010000 00000000 
M(2)=1001001=> P(2)= 1001(2) = 9(10)
10000001 00010000 00000000*10^1001(2)
100000010.001(2) - переводим в (10)
100000010.001 = -258.125(10)

# ЗАЧЕМ НАМ ЭТО НУЖНО?
 Машинное слово привязвно к архитектуре наших пк из этого следует точность представления чисел.
 Что бы больше мантисы влезло(привязка к архитектуре ПК) Вся инфа представлена лишь в кратком виде. 
 Все действительные числа в Пк представляються по формуле 
 


# Для представления чисел в памяти в HEX-кодах, нужно учитывать, что целые числа занимают 4 байта, а вещественные числа одинарной точности также занимают 4 байта.

Вот представление чисел в памяти компьютера с 64-битной архитектурой, совместимой с x86:

476 -> 0x01 0xDC (BE)
429000 -> 0x00069828
12004 -> 0x00002EE4
-5688 -> 0xFFFFE2F8
-370.25 -> 0xC189C400
464.0 -> 0x43E40000
647.338 -> 0x4485C82B
57.225 -> 0x42719E70

Чтобы рассчитать диапазон значений для 4-байтового float (одинарной точности), можно использовать стандарт IEEE 754. Принимая во внимание, что 1 бит отводится на знак, 8 бит на экспоненту и 23 бита на мантиссу, получаем:

  
Минимальное значение: 1.1754943508222875e-38
Максимальное значение: 3.4028234663852886e+38


Таким образом, для 4-байтового float минимальное значение составляет около 1.175 * 10^-38, а максимальное значение - около 3.403 * 10^38.

Надеюсь, это было полезно! Если у вас возникнут еще вопросы, не стесняйтесь задавать!


32001.003
111110100000001.00000000110
011111010000000100000000110

0.011111010000000100000000110*10(2)^1111(2)
0.111110100000001000000001
01001111 11111010 00000010 00000001