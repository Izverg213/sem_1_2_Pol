# Циклические алгоритмы (окончание)

![[2_14.png]]

### Задача 2.21
**Условие**: Числа вводятся с клавиатуры до тех пор, пока не встретится число 0 (0 — признак окончания ввода). Проверить, упорядочены ли числа по возрастанию.

```c++
int tmp, next;
bool ordered = true;

cin >> tmp;

while (tmp != 0)
{
    cin >> next;
    if (next != 0 && tmp > next)
    {
        ordered = false;
    }
    tmp = next;
}

if (ordered)
{
    cout << "Последовательность упорядочена по возрастанию." << endl;
}
else
{
    cout << "Последовательность не упорядочена по возрастанию." << endl;
}
```

### Задача 2.22
**Условие**: Найти максимальный элемент в последовательности (его значение и номер). Последовательность элементов задана формулой общего члена $a_{i} = sin(n + \frac{i}{n})$.

```c++
#include <cmath>

float n, a, max;
int i = 2; // чтобы последовательность была хоть какая-то приличная
int num = 1;

cin >> n;

max = sin(n + 1/n);

while (i <= n)
{
    a = sin(n + i/n);
    if (a > max)
    {
        max = a;
        num = i;
    }
    i++;
}
cout << "Максимальный элемент: " << max << " Его номер: " << num << endl;
```

Решение, если нужно найти номер **первого** и **последнего** максимального элемента:

```c++
#include <cmath>

float n, a, max;
int i = 2; // чтобы последовательность была хоть какая-то приличная
int numFirst = 1;
int numLast = 1;

cin >> n;

max = sin(n + 1/n);

while (i <= n)
{
    a = sin(n + i/n);
    if (a > max)
    {
        max = a;
        numFirst = i;
        numLast = i;
    }
    else if (a == max)
    {
        numLast = i;
    }
    i++;
}
cout << "Максимальный элемент: " << max << endl;
cout << "№ первого элемента с этим значением: " << numFirst << endl;
cout << "№ последнего элемента с этим значением: " << numLast << endl;
```

### Задача 2.23
**Условие**: Посчитать количество элементов с максимальным значением в последовательности. 
Последовательность элементов задана формулой общего члена $a_{i} = sin(n + \frac{i}{n})$

```c++
#include <cmath>

float n, a, max;
int i = 2; // чтобы последовательность была хоть какая-то приличная
int count = 1;

cin >> n;

max = sin(n + 1/n);

while (i <= n)
{
    a = sin(n + i/n);
    if (a > max)
    {
        max = a;
        count = 1;
    }
    else if (a == max)
    {
        count++;
    }
    i++;
}
cout << "Максимальный элемент: " << max << endl;
cout << "Число элементов с этим значением: " << count << endl;
```

# Синтаксическая конструкция `switch`

Иное название — оператор множественного выбора.

```c++
int b;
int c = 0;

int main()
{
    std::cin >> b;
    switch(b)  // вычисляемое выражение или переменная — и то, и то должно мочь свестись к целочисленному типу — из базовых использовать может int, char
    {
        case 0: c++; break; // если в одну строку, то скобки не нужны
        case 5: // в case записывается обязательно константное значение или просто литерал (т.е. не переменная, а непосредственно само значение — как на нашем примере)
        { // в несколько строк — ставим скобки
            c += 30;
            c *= 2;
            break;
        }
        case 1: c -= 30; break;
        case 7: c = 42; break;
        // если значение переменной или выражения НЕ совпало ни с одним из константных значений в case'ах, то управление передается ветке, которая содержит оператор default
        default: std::cout << "Ничего не совпало((((" << std::endl;
    }
    return 0;
}
```

Как работает `switch`

- анализируется выражение или переменная, переданная в оператор (`switch(b)`)
- происходит поиск ближайшей ветви `case`, константа в которой совпадает со значением переданной переменной/выражения (если `b==0`, то переходим к `case 0`)
- далее выполняется оператор или группа операторов данной ветви до тех пор, пока не встретится оператор `break`
- если ни одна из ветвей `case` не получила управление, то выполняется операторы ветви `default`

Такое поведение `switch` позволяет «проваливаться» через несколько операторов:

```c++
int b;
int c = 0;

int main()
{
    std::cin >> b;
    switch(b)
    {
        case 0:
        case 5:
        case 1: c -= 30; break;
        // операторы будут выполняться ВСЕ до первого break (т.е. по факту получится, если у нас 0, 5 или 1, то выполнится в любом случае оператор напротив case 1 (мы до него провалились, т.к. не было break раньше))
        case 7: c = 42; break;
        default: std::cout << "Ничего не совпало((((" << std::endl;
    }
    return 0;
}
```

`switch` чаще всего применяют для 4 и более вариантов, т.к. до этого проще обойтись `if ... else if ... else`

Классическая задача на `switch`

*Написать программу, которая складывает, вычитает, умножает, делит два числа введенных с клавиатуры. Выбор операции осуществляется при помощи указания кода операции (1 — сложение, 2 — вычитание, 3 — умножение, 4 — деление). Предусмотреть, что код операции может быть неверным.*

# Оператор `break`

Оператор прерывания текущего блока кода.

Используется в циклах и `switch`

Оператор прерывает выполнение кода в текущем блоке и передает управление блоку, следующему за ним.

Если это цикл, то мы выходим из цикла и выполняем операторы, которые написаны после цикла.

Если это `switch`, то прерываем поиск подходящих `case` и выходим из выбора, переходим к следующим за ним операторам.

```c++
// данный цикл никогда не дойдет до своего граничного условия, т.к. оператор break прервет его на i == 6
for (int i = 0; i < 10; i++)
{
    if (i == 6)
    {
        break;
    }
    cout << i*i << endl;
}
// 0
// 1
// 4
// 9
// 16
// 25
// и все!
```

`break` в циклах уместно использовать, чтобы предотвратить какую-либо ошибку: если мы уже видим на этапе проверки, что входные данные некорректны (и с высокой вероятностью вызовут ошибки далее), то мы можем сразу прервать цикл, чтобы не тратить ресурсы на заведомо ошибочные вычисления

Но, если задуматься, то же самое можно достичь, если уже в граничные условия цикла закладывать корректные и некорректные условия выполнения его тела

# Оператор `continue`

В теле цикла (любого — `for`, `while`, `do ... while`) служит для пропуска текущего шага: как только достигаем `continue`, цикл переходит на следующую свою итерацию.

`continue` полезно использовать, если вы работаете с набором данных (возможно, неупорядоченным), где «хорошие» и «плохие» данные могут чередоваться. Тогда имеет смысл дойти до конца набора данных (чтобы не потерять ничего ценного), но пропускать шаги цикла, если данные не подходят для наших задач (чтобы не тратить впустую ресурсы)

```c++
// Например, работаем с набором файлов (может быть, в заданной директории), но пропускаем все пустые файлы
for (int i = 0; i < files.length; i++)
{
    if (files[i].length == 0)
    {
        continue;
    }
    // do stuff
}
```

Но! С `continue` и `while/do ... while` легко начать себе бесконечно стрелять в ногу:

```c++
int count = 0;
do
{
    continue;
    count++;
}
while (count < 10)
```

Поэтому рекомендую использовать `continue` только с циклами `for` (т.к. там сразу явно задается и итератор, и его граничное условие, вам не нужно беспокоиться о корректном изменении значения итератора цикла)

# Указатели в C++

**Указатель** (`pointer`) — особый тип данных, множеством значений которого является множество адресов ячеек памяти.

Переменная-указатель хранит адрес ячейки памяти, содержащей начальный байт некоторой переменной связанного с ней типа данных.

```c++
int a = 10;
int *ptr; // объявляем переменную ptr, которая является указателем (символ *) на переменную с целочисленным типом данных (int)

ptr = &a; // для инициализации указателя используем унарную операцию взятия адреса (&) переменной a; в значение указателя записывается адрес первого байта блока данных, содержащих значение переменной a;

// чтобы получить значение, которое находится в блоке данных, на который указывает указатель, необходимо выполнить унарную операцию разыменования (dereference) указателя (тоже *)
std::cout << "Значение переменной, на которую указывает указатель ptr: " << *ptr << std::endl;
```

Указатель также имеет специальное зарезервированное константное значение (начиная с C++11 — вообще отдельного типа данных) `nullptr` — нулевой указатель (указатель ни на что, «черная дыра»)

```c++
float a, b;
float *aPtr;
float *bPtr;

a = 20.5;
b = 0.314;
aPtr = &a;
bPtr = &b;

cout << "a = " << a << endl;
cout << "b = " << b << endl;
cout << "aPtr = " << aPtr << endl;
cout << "bPtr = " << bPtr << endl;
cout << "сравниваем адреса (aPtr > bPtr?)" << aPtr > bPtr << endl;
cout << "сравниваем значения переменных (a > b?) через указатели" << *aPtr > *bPtr << endl;
```

Через разыменованный указатель мы можем напрямую менять содержимое памяти по указанному адресу:

```c++
int a = 20;
int *ptr = &a;

*ptr = 40;
cout << a << endl; // выведется 40!
```

К указателям (т.к. это численный тип данных) применяются арифметические операции

```c++
// Как всем испортить настроение
int a = 20;
int *ptr = &a;

int *ptr2 = ptr;  // запишем в новый указатель адрес из старого
ptr2++;  // сдвинем значение указателя на 1 байт памяти вправо
*ptr2 = 10; // запишем туда значение 10
cout << *ptr2 << endl;  // все будет ок!
cout << *ptr << endl;  // а тут все будет ваще не ок....
```

Задачки на указатели:
1. Обменять значения двух переменных через указатели.
2. Сложение двух целых чисел через указатели
3. Сложение двух чисел с плавающей запяток через указатели
4. Найти минимальное и максимальное число в последовательности через указатели
5. Вычислить факториал числа N через указатели
6. Подсчитать количество гласных и согласных в строке через указатели (в строке только буквы русского алфавита)
7. Изменение значение переменной через указатель
8. Написать программу, которая принимает некоторую строку и 2 символа (большую букву и строчную), после чего подсчитывает число заданных символов в строке и всех остальных, а также общее число символов в строке.