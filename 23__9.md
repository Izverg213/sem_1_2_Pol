# Разбор НАМ домой

Перевод из 2-й СС в 10-ю

Алфавит: `{ 0 1 / }`
Допустимые подстановки
1. `1` -> `0/` 
2. `/0` -> `0//` 
3. `0` -> ` `
4. `/` -> * `/`

"*" — обозначение конца алгоритма. Если нельзя выполнить хотя бы 1 подстановку, алгоритм считается завершенным.

0. `1100`
1. 0/0/00
2. 00//0//0
3. 00/0///0//
4. 000////0////
5. 000///0//////
6. 000//0////////
7. 000/0//////////
8. 0000////////////:
9. ////////////

-----------

Написать и выполнить искомый НАМ:

#### 1.
Исходный A = {a, b}
Преобразовать W так, чтобы в его начале оказались все символы "a",а в конце — "b"
Например, babba -> aabbb

1. ba -> ab
2. b -> *b

0. babba
1. abbab
2. ababb
3. aabbb

#### 2.
Исходный A = {a, b}
Удалить из непустого W первый символ. Пустое слово не менять.
babba -> abba
abbba -> bbba

1. a -> n/
2. b -> s/
3. /n -> a
4. /s -> b
5. s -> 
6. n -> 
7. / -> *


0. babba
1. bn/bbn/
2. s/n/s/s/n/
3. sa/s/sa/
4. sabba/
5. abba/
6. abba

1. Xa -> *
2. Xb -> *
3. -> X

0. babba
1. Xbabba
2. abba


#### 3.
Расширить алгоритм (2) для пустых W в том числе

1. Xa -> *
2. Xb -> *
3. X -> *
4. -> X

#### 4. 
A = {0, 1, 2, 3 }
Пусть W — непустое слово. Представим W как запись неотрицательного целого числа в 4-й СС. Составить НАМ для получения записи числа в 2-й СС.

1. X0 -> 00X
2. X1 -> 01X
3. X2 -> 10X
4. X3 -> 11X
5. X -> *
6. -> X

0. 12
1. X12
2. 01X2
3. 0110X

0123

1. X0123
2. 00X123
3. 0001X23
4. 000110X3
5. 00011011X
6. 00011011

Интерпретатор НАМ: https://yad-studio.github.io/ (один из)

# Блок-схемы и их основные элементы

> Все соединения направленные (имеют стрелочку направления) и ортогональными (только прямые углы)

- Терминатор (ограничитель) — элемент, обозначающий начало и конец алгоритма.
- Действие (операция) — обозначает выполнение определенной операции.
- Комментарий — полезная информация, не являющаяся непосредственной частью алгоритма.
- Данные (блок ввода-вывода) — обозначает операцию ввода-вывода каких-либо данных, например, ввод пользователем своего имени, выбор даты, вывод расписания и т.д. Чтение и запись в файлы — тоже операции ввода-вывода.
- Условный оператор — обозначает условное выражение и требует «плечей» — двух путей алгоритма с указанием истинности (или ложности) для каждого из них.
- Функция (процедура) — вызов заранее определенной подпрограммы, алгоритм которой указан в другом месте блок-схемы или отдельной схеме (например, функция стандартной библиотеки)
- Оператор цикла с параметром (`for`) — для указания всех параметров цикла в одном блоке.
- Соединитель — для разбиения и соединения блок-схемы на 2 и более части (например, для переноса на следующую страницу)

# Основные типы данных и структура программы на языке C++

## Основные типы данных

- `int` — целое число
- `float` — число с плавающей точкой стандартной (одинарной) точности
- `double` — число с плавающей точкой двойной точности; под него выделяется в 2 раза больше памяти для хранения 1 переменной, существенно увеличивая количество разрядов мантиссы, которые могут храниться в памяти до округления; используется тогда, когда точность важнее занимаемой памяти.
- `bool` — логические значения, `True`/`False`.
- `char` — символьные данные, хранятся коды символов.
- `wchar_t` — «широкий» символ, его размер должен быть достаточен для любой кодовой точки Юникода (т.е. обычно 32 бита)
    - `char8_t`, `char16_t`, `char32_t` — типы символьных данных, под которые выделяются ровно 8/16/32 бита.
- `void` — особый тип данных с пустым множеством допустимых значений.

## Модификаторы

Модификаторы — ключевые слова, применяемые к определенным типам данных, изменяющие диапазон их значений.

###  Модификаторы int

- `signed` — целевой тип данных будет иметь знаковое представление (т.е. в диапазон войдут поровную отрицательные и неотрицательные значения). **Применяется по умолчанию, если не указано обратное**.
- `unsigned` — целевой тип данных будет иметь беззнаковое представление (т.е. в диапазон попадут только неотрицательные значения).
- `short` — целевой тип данных будет оптимизирован в памяти так, чтобы иметь минимальный размер (т.е. не менее) 16 бит.
- `long` — целевой тип данных будет иметь размер не менее 32 бит (в реальных современных моделях данных чаще всего 64 бит)
- `long long` — целевой тип данных будет иметь размер не менее 64 бит.

Примеры:

```c++
signed short int a;  // в памяти занимает 16 бит, значения + и -

 short int b; // то же, что переменная a

 unsigned short int c; // 16 бит, неотрицательные значения

 long long int d;  // 64 бита, + и - значения
 
 unsigned long long int e;  // 64 бита, неотрицательные значения
```

### Модификаторы double

- `long` — целевой тип данных будет соответствовать формату повышенной точности (128 бит на 1 переменную)

### Модификаторы char

- `signed` — целевой тип данных будет иметь знаковое представление (т.е. в диапазон войдут поровную отрицательные и неотрицательные значения).
- `unsigned` — целевой тип данных будет иметь беззнаковое представление (т.е. в диапазон попадут только неотрицательные значения).

При этом char представляет символы так, чтобы эффективность их обработки была самой высокой. **Знаковость char по умолчанию зависит от компилятора и целевой платформы**. Для ARM значения обычно беззнаковые, для x86/x86_64 — знаковые.

Диапазон 8-битного char может быть [-128, 127] или [0, 255].

Пример кодов для знакового представления символа:

```c++
65 = A
66 = B
67 = C
68 = D
69 = E
70 = F
71 = G
72 = H
73 = I
74 = J
75 = K
76 = L
77 = M
78 = N
79 = O
80 = P
81 = Q
82 = R
83 = S
84 = T
85 = U
86 = V
87 = W
88 = X
89 = Y
90 = Z
91 = [
92 = \
93 = ]
94 = ^
95 = _
96 = `
97 = a
98 = b
99 = c
100 = d
101 = e
102 = f
103 = g
104 = h
105 = i
106 = j
107 = k
108 = l
109 = m
110 = n
111 = o
112 = p
113 = q
114 = r
115 = s
116 = t
117 = u
118 = v
119 = w
120 = x
121 = y
122 = z
123 = {
124 = |
125 = }
126 = ~
127 = 
-128 = €
-127 = �
-126 = ‚
-125 = ƒ
-124 = „
-123 = …
-122 = †
-121 = ‡
-120 = ˆ
-119 = ‰
-118 = Š
-117 = ‹
-116 = Œ
-115 = �
-114 = Ž
-113 = �
-112 = �
-111 = ‘
-110 = ’
-109 = “
-108 = ”
-107 = •
-106 = –
-105 = —
-104 = ˜
-103 = ™
-102 = š
-101 = ›
-100 = œ
-99 = �
-98 = ž
-97 = Ÿ
-96 =  
-95 = ¡
-94 = ¢
-93 = £
-92 = ¤
-91 = ¥
-90 = ¦
-89 = §
-88 = ¨
-87 = ©
-86 = ª
-85 = «
-84 = ¬
-83 = ­
-82 = ®
-81 = ¯
-80 = °
-79 = ±
-78 = ²
-77 = ³
-76 = ´
-75 = µ
-74 = ¶
-73 = ·
-72 = ¸
-71 = ¹
-70 = º
-69 = »
-68 = ¼
-67 = ½
-66 = ¾
-65 = ¿
-64 = À
-63 = Á
-62 = Â
-61 = Ã
-60 = Ä
-59 = Å
-58 = Æ
-57 = Ç
-56 = È
-55 = É
-54 = Ê
-53 = Ë
-52 = Ì
-51 = Í
-50 = Î
-49 = Ï
-48 = Ð
-47 = Ñ
-46 = Ò
-45 = Ó
-44 = Ô
-43 = Õ
-42 = Ö
-41 = ×
-40 = Ø
-39 = Ù
-38 = Ú
-37 = Û
-36 = Ü
-35 = Ý
-34 = Þ
-33 = ß
-32 = à
-31 = á
-30 = â
-29 = ã
-28 = ä
-27 = å
-26 = æ
-25 = ç
-24 = è
-23 = é
-22 = ê
-21 = ë
-20 = ì
-19 = í
-18 = î
-17 = ï
-16 = ð
-15 = ñ
-14 = ò
-13 = ó
-12 = ô
-11 = õ
-10 = ö
-9 = ÷
-8 = ø
-7 = ù
-6 = ú
-5 = û
-4 = ü
-3 = ý
-2 = þ
-1 = ÿ
0 = NULL
```

## Спецификаторы, объявление и инициализация переменных

Объявление переменной — процедура резервирования количества байтов памяти, необходимого для хранения переменной указанного типа.

(здесь и далее рассматривается модель данных для 64-битных систем)

```c++
int a; // объявление. В памяти резервируются 32 бита (4 байта), идущие друг за другом в строгой последовательности. Переменной `a` присваивается адрес первого байта из этих 4.
```

При этом содержимое памяти не меняется в момент объявления переменной — если там были какие-то «левые», старые данные, они там и останутся (т.н. «мусор»).

Инициализация переменной — запись в переменную какого-либо первичного значения (и, следовательно, перезапись данных в этом участке памяти).

```c++
int a; // объявление
a = 0; // инициализация

// Обе процедуры можно сделать в одну строку, но их все еще 2!
int b = 0;
```

Спецификатором называют указание на тип данных при объявлении переменной.

Например, особый спецификатор `auto` (C++ 11 и выше), который работает только при синтаксисе объявление+инициализация в 1 строку.

```c++
auto a; // не сработает, нет понимания, сколько и под что резервировать память

auto b= 1;     // смотрим на значение — похоже на int, заменяем auto на int
auto c = 1.0;  // смотрим на значение — похоже на float, заменяем auto на float

// где auto полезно
map<int, int>::iterator j = myMap.begin();
auto j = myMap.begin();

//списки инициализации требуют согласованности типов для auto

auto a = {4, 5.0}  / ошибка, в списке 2 разных типа — неясно, к какому отнести переменную
```

**auto — НЕ ТИП ДАННЫХ!**

Еще один спецификатор, применяемый ВМЕСТЕ со спецификатором типа (или auto) — `const`

`const` — указывает, что переменная является константой, содержащееся в ней значение, полученное при инициализации, заменить на какое-либо другое нельзя

```c++
const int a = 2;
a = 3; // выдаст ошибку, попытка присвоения константе нового значения
```

Противоположность `const` — `volatile`. Он разрешает *конкуретное* изменение переменной (например, при обращении к ней нескольких потоков одновременно)
