# Задачи на указатели

## 1. Обменять значения двух переменных через указатели.

```c++
int a, b, tmp;
int *ptr1;
int *ptr2;

cin >> a;
ptr1 = &a;
tmp = *ptr1;
cin >> b;
ptr2 = &b;
*ptr1 = *ptr2;
*ptr2 = tmp;

cout << *ptr1 << endl;
cout << *ptr2 << endl;
```

## 2. Сложение двух целых чисел через указатели

```c++
int a, b, *ptr1, *ptr2, sum = 0;

cin >> a >> b;
ptr1 = &a;
ptr2 = &b;
sum = *ptr1 + *ptr2;
cout << sum << endl;
```

## 3. Сложение двух чисел с плавающей запятой через указатели

```c++
float a, b, *ptr1, *ptr2, sum = 0;

cin >> a >> b;
ptr1 = &a;
ptr2 = &b;
sum = *ptr1 + *ptr2;
cout << sum << endl;
```

## 4. Найти минимальное и максимальное число в последовательности через указатели

```c++
int n, tmp, *ptr=&tmp, max, min;

cout << "Введите длину последовательности:\n";
cin >> n;
cout << "Введите первое число:\n";
cin >> *ptr;
max = *ptr;
min = *ptr;

for (int i = 2; i <= n; i++)
{
    cin >> *ptr;
    if (*ptr > max) { max = *ptr; }
    else if (*ptr < min) { min = *ptr; }
}
cout << "Максимальный элемент: " << max << endl;
cout << "Минимальный элемент: " << min << endl;
```

## 5. Вычислить факториал числа N через указатели

```c++
unsigned int n, fact=1;
unsigned int *f = &fact;

cin >> n;

for (int i = 1; i <= n; i++)
{
    *f *= i;
}
cout << "Факториал " << n << " равен " << fact << endl;
```

## 6. Подсчитать количество гласных и согласных в строке через указатели (в строке только буквы русского алфавита)

```c++
#include <iostream>
#include <string>

int main() {
    std::setlocale(LC_ALL, "Russian");
    int countC = 0;
    int countV = 0;
    std::string st;
    std::cout<<"Введите строку"<<std::endl;
    std::cin>>st;   
    const char* pt = st.c_str();
    for (int i = 0; i < st.length(); i++)
    {
        char tmp = tolower(*pt);
        std::cout << tmp << std::endl;
        if(tmp==L'а' ||tmp==L'е' ||tmp==L'и' ||tmp==L'о' ||tmp==L'у' ||tmp==L'э' ||tmp==L'ю' ||tmp==L'я' )
        { countV++; }
        else { countC++; }
        pt++;
    }
    
    std::cout<<"Количество гласных:  "<<countV<<std::endl;
    std::cout<<"Количество согласных:  "<<countC<<std::endl;
    return 0;
}
```

7. Изменение значение переменной через указатель

```c++
int n;
int* ptr = &n;

cin >> *ptr;

cout << n;
```

8. Написать программу, которая принимает некоторую строку и 2 символа (большую букву и строчную), после чего подсчитывает число заданных символов в строке и всех остальных, а также общее число символов в строке.

# Ссылки (reference)

Ссылка — объект, который указывает на какие-либо данные, но сам их не хранит.

Получение объекта по ссылке тоже называется разыменованием (dereferencing)

Ссылка != указатель

Ссылка — просто еще одно название/имя объекта.

Для указателей доступны операции:

- арифметика с целыми числами
- копирование
- разыменование

Для ссылок:

- копирование
- разыменование

Оператор ссылок — `&`.

Указатель *может* рассматриваться как вариант ссылки в некоторых контекстах, но в C++ нельзя ставить знак равенства между ними.

```c++
// <Type>& <Name>

int n = 5;
int& ref = n;
```

Ссылка безопаснее указателя, но, поскольку ей доступно меньше операций, область ее применения также меньше.

# Указатели высших порядков

Указатели на указатели

Указатель высшего порядка — указатель, который содержит в качестве значения адрес другого указателя более низкого порядка.

```
**ptr1 -> *ptr0 -> value
```

Указатели высших порядков могут использоваться для опосредованного доступа к значению по адресу, сохраненному в указателе первого порядка. Для этого нужно применить операцию разыменования столько раз, сколько уровней (порядков) у указателя:

```c++
int a;
int *ptr;
int **pptr;

a = 3782;

ptr = &a; // записываем адрес переменной a в указатель первого порядка ptr
pptr = &ptr; // записываем адрес указателя первого порядка ptr в указатель второго порядка pptr

cout << **pptr << endl; // выводим 3782 через 2 операция разыменования через указатель второго порядка
```

Чаще всего указатели высших порядков используются для доступа к значениям, хранящимся во вложенных структурах данных (например, многомерных массивах)

```c++
int **arr;
int n = 6;
int m = 5;

arr = new int*[n];

for (int i = 0; i < n; i++)
{
    arr[i] = new int[m];
}
```

# Методы решения нелинейных уравнений

## Метод половинного деления

```c++
// f(x) = x^3 - x - 1
// [1; 2]

#include <iostream>
#include <cmath>

using namespace std;

int main()
{
    float a, b, c;
    float fA, fB, fC;
    double eps = 0.000001;

    a = 1;
    b = 2;

    while (b-a > eps)
    {
        c = (a + b) / 2;
        fA = (pow(a, 3) - a - 1);
        fB = (pow(b, 3) - b - 1);
        fC = (pow(c, 3) - c - 1);
        if (fA * fC < 0) { b = c; }
        else if (fC * fB < 0) { a = c; }
        else { cout << "Что-то не то!" << endl; }       
    }
    cout << "Корни: " << a << "; " << b << endl;
    return 0;
}
```
## Метод Ньютона (метод касательных)

```c++
// f(x) = x^3 - x - 1;
// f'(x) = 3x^2 - 1;
// f''(x) = 6x;
// [1, 2]

#include <iostream>
#include <cmath>

using namespace std;
int main()
{
    float x, xPrev;
    // проверяем, берем ли мы сначала a или b за начальное значение x
    // f(b) * f''(b) > 0
    // (8 - 2 - 1) * (6*2) > 0 => x0 = b;
    // если бы условие не выполнилось, нужно проверить это с a
    x = 2;  // x0 = b;
    xPrev = 0;  // инициализируем переменную x(n-1)
    double eps = 0.000001;

    while(abs(x - xPrev) > eps)
    {
        xPrev = x;
        // сюда мы пишем формулу, где x(i-1) - f(x(i-1)) / f'(x(i-1))
        x = xPrev - ( (pow(xPrev, 3) - xPrev - 1) / (3*pow(xPrev, 2) - 1) )
    }
    cout << "Корень: " << x << endl;
    return 0;
}
```

## Метод итераций

```c++
// f(x) = x^3 - x - 1
// f'(x) = 3x^2 - 1;
// f''(x) = 6x;
// [1, 2]
// ф(x) = x + λ(x^3 - x - 1)
// -1/r < λ < 0, если f'(x) > 0
// 0 < λ < 1/r, если f'(x) < 0
// r = max(|f'(a)|, |f'(b)|)
// r = max(|3*1^2 - 1|, |3*2^2 - 1|) = max(2, 11) = 11
// f'(x) > 0 => -1/r < λ < 0
// берем любое удобное число в диапазоне
// λ = -1/20 = -0.05

#include <iostream>
#include <cmath>

using namespace std;
int main()
{
    float x, xPrev;
    double lambda = -0.05; // -1/20
    x = 2; // можно выбрать любое x0 из [1, 2] — выбранного заранее промежутка — a или b по желанию
    xPrev = 0;  // делаем заведомо меньше x
    double eps = 0.000001;

    while (abs(x - xPrev) > eps)
    {
        xPrev = x;
        x = lambda * (pow(xPrev, 3) - xPrev - 1) + xPrev;
    }
    cout << "Корень по методу итераций: " << x << endl;
    return 0;
}
```
