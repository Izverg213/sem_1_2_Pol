# Алгоритм и его свойства

Алгоритм — последовательность действий, ведущих от некоторых исходных данных к некоторому заданному (необходимому) результату.

Свойства алгоритма:

1. Детерминированность (определненность) — каждое действие алгоритма **однозначно** и понятно его исполнителю, что ведет к **однозначному** результату;
2. Массовость — алгоритм должен решать не одну задачу, а класс подобных задач, отличающихся исходными данными.
3. Конечность — получение результата гарантируется за некоторое конечное время.

Не все задачи являются алгоритмическими по свей природе. Например, к таким задачам относятся воспитание ребенка, рисование картины художником и т.п.

Не все задачи имеют алгоритм их решения, хотя считаются принципиально алгоритмизуемыми (например, разбиение угла на три равные части циркулем и линейкой)

Для решения одной и той же задачи может существовать более одного алгоритма (можно по-разному простроить маршрут до одной и той же точки в городе из какой-либо другой)

Простейший пример алгоритма — переход дороги со светофором

0. Начало.
1. Посмотреть на светофор. Если горит зеленый, то перейти на шаг 3.
2. Стоять и ждать, пока не загорится зеленый.
3. Начать движение, смотря налево до середины дороги.
4. Продолжить движение, смотря направо.
5. Конец.

# Формы представления (модели) алгоритмов

1. Словесная (пример со светофором, варка пельменей, приготовление доширака с сосисками и т.п.)
2. Блок-схема (flowchart — diagrams.net как инструмент их рисования)
3. Программа на алгоритмическом языке

## Требования к моделям алгоритмов

1. Простота — выделение действительно необходимых элементов и их свойств.
2. Универсальность — модель должна быть пригодна для описания любого алгоритма.

Псевдокод — словесная + программная (имитация кода программы с помощью слов естественного языка)

# Классы арифметических моделей

## 1 класс. Основан на арифметизации алгоритма

- любые шаги можно закодировать числами
- шаги представляют собой арифметические операции
- последовательность можно задать формулой

Алгоритм — вычисление некоторой числовой функции.

Последовательность (формула) задается при помощи двух приемов:

1. Суперпозиция — подстановка одной формулы в другую, т.е. вводится набор элементарных операций, с помощью которых строятся более сложные выражения. Например: `(a * b) + (c / d)` является суперпозицией операций сложения `x + y`, умножения `x * y` и деления `x / y`.
2. Рекурсия — задает функции через самих себя (например, вычисление факториала или чисел Фибоначчи)

Например, высисление факториала на C++:

```c++
int factorial(int n)
{
    if (n <= 1) { return 1; }
    else { return n * factorial(n-1); }
}
```

```python
def factorial(n: int) -> int:
    if n <= 1:
        return 1
    else:
        return n * factorial(n-1)
```

## 2 класс. Предназначен для выполнения некоторой машиной, к которой предъявляются требования простоты и универсальности

К таким машинам относитяс **абстрактная машина Тьюринга**
Машина Тьюринга - Абстрактная модель вычеслений, предложенная англи математиком Аланом Тьюринга(1936)
Она определяет; 
- Вычислимость функции
Решает проблема определения: Можно ли создать алгоритм который определит будет ли работать другой алгоритм(будет ли конечный) при новом наборе входных данных. 

В состав АМТ входят:

1. бесконечная в обе стороны лента, разделенная на ячейки;
2. управляющее устройство, способное находиться в одном из множества заданных состояний (число состояний заранее задано и всегда конечно)
3. пищущая головка, которая может записывать поверх символы в ячейку
4. заданный конечный алфавит, символы которого могут быть записаны в ячейки (в алфавит обязательно входит специальный `пустой` символ, который заполняет все ячейки, кроме тех, в которые записаны входные данные)
5. правила перехода, в которых записан алгоритм, реализуемый данной АМТ. Каждое правило перехода предписывает машине (в зависимости от текущего состояния и наблюдаемого символа в ячейке) записать в текущую ячейку новый символ, перейти в новое состояние и переместиться на одну ячейку влево, вправо или остаться на месте. При этом и новый символ, и новое состояние могут совпадать с текущими. Некоторые состояния могут помечаться как `терминальные`, при переходе в такое состояние выполнение алгоритма останавливается, т.е. АМТ завершает работу. В любом алгоритме должно быть минимум 1 терминальное состояние.

АМТ считается детерминированной, если каждой комбинации состояния и символа в таблице переходов соответствует не более 1 правила. Если существует более 1 правила, то АМТ недетерминированная.

Наиболее близким к АМТ исполнителем алгоритмов является ДНК-полимераза и процесс восстановления ДНК (репарация). ДНК-полимераза и другие белки движутся по ленте ДНК и считывают ее половинки. Если информация не совпадает, то ДНК-полимераза принимает одну из них за образец и исправляет другую.

Шаг машины тьюринга это 
## З класс. Нормальные алгоритмы (Нормальный Алгоритм Маркова, нормальные марковские модели)

НАМ представляет алгоритм как набор строк, которые последовательно переписываются в соответствии с множеством допустимых подстановок и порядком их применения.

НАМ задается: 

1. алфавит;
2. множеством допустимых подстановок;
3. порядком применения подстановок.

НАМ эквивалентен АМТ (и является полным по Тьюрингу), т.е. каждый алгоритм для АМТ можно представить как НАМ. Следовательно, НАМ можно реализовать на любом современном языке программироавния, аналогично алгоритмам для АМТ.

## Пример решения задачи алгоритмом для АМТ

Задача: записать результат умножения на основе числа палочек, выложенных во входных данных. Умножение производится в 10-й СС

Обозначения в таблицах переходов АМТ

- `q(i)` — состояние, при котором правило выполняется
- `a(j)` — данные в ячейке, которые прочитала головка чтения/записи
- `q(i)1` — состояние, в которое нужно перейти
- `a(j)1` — символ (данные), которые будут записаны в ячейку
- R/L/N — команда перемещения (вправо, влево, стоять на месте)

Пример записи правила перехода

`q(i) a(j) -> q(i)1 a(j)1 R` — находясь в состоянии `q(i)` и встретив символ `a(j)`, перейти в состояние `q(i)1`, записать символ `a(j)1` и сдвинуться на 1 клетку ВПРАВО.

1. Определяем алфавит для алгоритма 

`{ 1, *, =, a, @, NULL }`

В алфавит вошли: символ для обозначения числа (палочка), символ умножения, символ равенства, временный символ, символ границы выражения и пустой символ

| Сим/Сост | q0               | q1               | q2               | q3               | q4               | q5               | q6               | q7               | q8               | q9                  |
| -------- | --               | --               | --               | --               | --               | --               | --               | --               | --               | --                  |
|     1    | `q0 1 -> q0 1 R` | `q1 1 -> q2 a R` | `q2 1 -> q2 1 L` | `q3 1 -> q4 a R` | `q4 1 -> q4 1 R` |                  |                  | `q7 1 -> q2 a R` |                  |                     |
|     *    | `q0 * -> q1 * R` |                  | `q2 * -> q3 * L` |                  | `q4 * -> q4 * R` |                  | `q6 * -> q7 * R` |                  | `q8 * -> q9 * N` | `q9 * -> q9 * HALT` |
|     =    |                  |                  | `q2 = -> q2 = L` |                  | `q4 = -> q4 = R` |                  |                  | `q7 = -> q8 = L` |                  |                     |
|     a    |                  |                  | `q2 a -> q2 a L` | `q3 a -> q3 a L` | `q4 a -> q4 a R` |                  | `q6 a -> q6 1 R` | `q7 a -> q7 a R` | `q8 a -> q8 a L` |                     |
|     @    | `q0 @ -> q0 @ R` |                  |                  | `q3 @ -> q6 @ R` | `q4 @ -> q5 1 R` |                  |                  |                  |                  |                     |
|          |                  |                  |                  |                  |                  | `q5   -> q2 @ L` |                  |                  |                  |                     |

0. `q0 [@]1111*11=@`
1. `q0 @[1]111*11=@`
2. `q0 @1[1]11*11=@`
3. `q0 @11[1]1*11=@`
4. `q0 @111[1]*11=@`
5. `q0 @1111[*]11=@`
6. `q1 @1111*[1]1=@`
7. `q2 @1111*a[1]=@`
8. `q2 @1111*[a]1=@`
9. `q2 @1111[*]a1=@`
10. `q3 @111[1]*a1=@`
11. `q4 @111a[*]a1=@`
12. `q4 @111a*[a]1=@`
13. `q4 @111a*a[1]=@`
14. `q4 @111a*a1[=]@`
15. `q4 @111a*a1=[@]`
16. `q5 @111a*a1=1[]`
17. `q2 @111a*a1=[1]@`
....
nn. `q2 @111a[*]a1=1@`
nn. `q3 @111[a]*a1=1@`
nn. `q3 @11[1]a*a1=1@`
nn. `q4 @11a[a]*a1=1@`
N.  `q4 @11aa[*]a1=1@`
N.  `q4 @11aa*[a]1=1@`
N.  `q4 @11aa*a[1]=1@`
N.  `q4 @11aa*a1[=]1@`
N.  `q4 @11aa*a1=[1]@`
N.  `q4 @11aa*a1=1[@]`
N.  `q5 @11aa*a1=11[]`
N.  `q2 @11aa*a1=1[1]@`
...
N.  `q3 [@]aaaa*aa=11111111@`
N.  `q6 @[a]aaa*aa=11111111@`
...
N.  `q6 @aaaa[*]aa=11111111@`
N.  `q7 @aaaa*[a]a=11111111@`
...
N.  `q7 @aaaa*aa[=]11111111@`
N.  `q8 @aaaa*a[a]=11111111@`
....
N.  `q8 @aaaa[*]aa=11111111@`
N.  `q9 @aaaa[*]aa=11111111@`
N. ` q9 HALT`

## Пример решения задачи НАМ

1. Алфавит: `{а...я А...Я 0...9 /пробел/ .}`
2. Допустимые подстановки и порядок их применения
    1. `А` -> `Анатолий`
    2. `ГБ` -> `гигабайт`
    3. `кг` -> `килограмм`
    4. `т.р.` -> `тысяч рублей`
    5. `тысяч рублей` -> `тысяч рублей. HALT`

Исходная строка: `А купил диск на 500 ГБ весом 3 кг за 15 т.р.`

0. `А купил диск на 500 ГБ весом 3 кг за 15 т.р.`
1. `Анатолий купил диск на 500 ГБ весом 3 кг за 15 т.р.`
2. `Анатолий купил диск на 500 гигабайт весом 3 кг за 15 т.р.`
3. `Анатолий купил диск на 500 гигабайт весом 3 килограмм за 15 т.р.`
4. `Анатолий купил диск на 500 гигабайт весом 3 килограмм за 15 тысяч рублей`
5. `Анатолий купил диск на 500 гигабайт весом 3 килограмм за 15 тысяч рублей. HALT`

### Пример 2: Перевод из 2-й в 10-ю СС

Алфавит: `{ 0 1 / }`
Допустимые подстановки
1. `1` -> `0/` 
2. `/0` -> `0//` 
3. `0` -> ``
4. `/` -> * `/`

"*" — обозначение конца алгоритма. Если нельзя выполнить хотя бы 1 подстановку, алгоритм считается завершенным.

0. `101`
1. `0/00/`
2. `00//0/`
3. `00/0///`
4. `000/////`
5. `/////`

### Общий вид подстановок

`L` -> `D`, где `L` и `D` — любые две комбинации символов алфавита.

`L` -> * `D`, где `L` и `D` — любые две комбинации символов алфавита, * — обозначение конца выполнения алгоритма

`W` — исходное слово, составленное из символов алфавита. Каждый шаг алгоритма порождает `W'` — слово, полученное в результате выполнения алгоритма на предыдущем шаге.

Для каждого следующего шага за исходное принимается полученное на прошлом шаге `W'`

0. `W`
1. `W` -> `W'`
2. `W'` -> `W''`

- Если в множестве допустимых подстановок НЕТ таких подстановок, ЛЕВАЯ (`L`) часть которых входила бы в `W'`, то работа алгоритма считается завершенной. Результат — `W'`.
- ИНАЧЕ выбирается самая первая из допустимых постановок, `L` которой входит в `W`.
- ЕСЛИ эта подстановка является заключительной вида `L` - > * `D`, то из всех представлений `W'` в виде `RLS` (`R`, `S` — некоторые иные наборы символов алфавита, не относящиеся к подстановке) выбирается такое, при котором `R` является наиболее короткой последовательностью символов, после чего алгоритм считается завершенным с результатом `RDS`.
- ЕСЛИ эта подстановка является простой вида `L` - > `D`, то из всех представлений `W'` в виде `RLS` (`R`, `S` — некоторые иные наборы символов алфавита, не относящиеся к подстановке) выбирается такое, при котором `R` является наиболее короткой последовательностью символов, после чего `RDS` считается промежуточным результатом и подлежит дальнейшей обработке.

### Примеры на НАМ домой
Перевод из 2-й СС в 10-ю

Алфавит: `{ 0 1 / }`
Допустимые подстановки
1. `1` -> `0/` 
2. `/0` -> `0//` 
3. `0` -> ` `
4. `/` -> * `/`

"*" — обозначение конца алгоритма. Если нельзя выполнить хотя бы 1 подстановку, алгоритм считается завершенным.

0. `1100`
1. 0/0/00
2. 00//0//0
3. 00/0///0//
.....
9. ////////////
-----------

Написать и выполнить искомый НАМ:

#### 1.
Исходный A = {a, b}
Преобразовать W так, чтобы в его начале оказались все символы "a",а в конце — "b"
Например, babba -> aabbb

Решение:
1. 'ba' -> 'ab'

#### 2.
Исходный A = {a, b}
Удалить из непустого W первый символ. Пустое слово не менять.
babba -> abba
abbba -> bbba

Решение:
1. '*a' -> *' '
2. '*b' -> *' '
3. ' ' -> '*'

#### 3.
Расширить алгоритм (2) для пустых W в том числе

Решение:
1. '*a' -> *' '
2. '*b' -> *' '
3. '*' -> *' '
4. ' ' -> '*'

#### 4.
A = {0, 1, 2, 3 }
Пусть W — непустое слово. Представим W как запись неотрицательного целого числа в 4-й СС. Составить НАМ для получения записи числа в 2-й СС.

Решение:
1. '*0' -> '00*'
2. '*1' -> '01*'
3. '*2' -> '10*'
4. '*3' -> '11*'
5. '*' -> ' '
6. '#0' -> *' '
7. '#' -> *' '
8. ' ' -> '#*'