# Примеры

103 -> 147(8)
419 -> 1A3(16)
37 -> 100101(2)

0,875 -> 0,32(4)
0,145 -> 0,03303(5)
0,216 -> 0,374BC(16)
0,525 -> 0,41463(8)
42,78 -> 222,30132(4)

Выполнить действия:

C37ED(16) + 8FF92(16) = 15377F(16)
757(8) - 355(8) = 402(8)
102(16) + CEF (16) = DF1(16)
DF1(16) + A82(16) =  1873(16)
1873(16) + 3E(16) = 18B1(16)

В десятичную СС перевести по Горнеру::

10640(8) = 4512
54025(6) = 7361
111121(3) = 367
1022003(4) = 4739
12886(9) = 8745
-----

Перевести из десятичной в заданную СС

0.727 (6-я) = 0,42101(6)
0.901 (3-я) = 0,22002(3)
0.683 (9-я) = 0,61281(9)
0.6546 (7-я) = 0,44034(7)
0.2346 (5-я) = 0,10413(5)
0,7734 (2-я) = 0,110001 (2)
633.372 (8-я) = 1171,27635 (8)
432,052 (16) =  1B0,0D4FD(16)
331,635 (6) = 1311,34505(6)
23,45 (2) = 10111,0111001(2)

В 2-ю
503 = 111110111
1346 = 10101000010
3468 = 110110001100
1517 = 10111101101

В 4-ю
806 = 30212
1473 = 113001
52,225 =  310,03212

В 8ю
-104,33 = -150,25075(8)
546,11 = 1042,07024(8)
1083 = 2073 (8)
3931 = 7533 (8)

В 16ю
51738 = CA1A
2160 =  870
443,73 = 1BB.BAE14
1080,72 = 438,B851E

# Перевод чисел с мантиссой в 10-ю СС из любой другой по схеме Горнера

0,4345 (6) -> 10ю по схеме Горнера

Модификация метода Горнера для мантиссы

1. Движемся *справа налево*
<--------<
0,4345 (6)

2. Заменяем все операции умножения операциями деления

((((((5/6)+4) / 6)+3 ) / 6) + 4)/6 = 0,772376

("0" + 5) / 6 = 0,833
(0,833 + 4) / 6 = 0,8055
(0,8055 + 3) / 6 = 0,63425
(0,63425 + 4) / 6 = 0,772375

Мнемоника

1. Если переводим целую часть — операций сложения и операций умножения на 1 больше, чем число разрядов
2. Если переводим дробную часть — операций деления столько же, сколько разрядов, а операций сложения на 1 меньше


# Представление информации в ЭВМ

## Числовая система ЭВМ

Напрямую связана с кодированием информации

1. Кодирование — формирование представления информации. Переход от исходного представления информации (удобного для восприятия человеком) к представлению, удобному для хранения, передачи и обработки информации.
2. Декодирование — обратный кодированию процесс.

## Цели кодирования

1. удобство физической реализации (техника, «железо»)
2. удобство восприятия
3. высокая скорость передачи и обработки
4. экономичность (снижение избыточности сообщения)
5. надежность (защита от случайных искажений)
6. сохранность (защита от нежелательного, несанкционированного доступа)

Цели противоречат друг другу!

Примеры противоречий:

Если в приоритете экономичность — снижается надежность и удобство восприятия

Если в приоритете малая длина сообщения — повышается сложность обработки (например — архивация данных через ZIP)

Если в приоритете защита (сохранность и/или надежность) — снижается объем доступной для хранения информации и повышается сложность обработки и работы с ней (например — RAID-массивы /Redundant Array of Independent Disks/ RAID5 снижает доступное место для хранения информации на объем 1 диска в массиве, приэ этом 1 диск может выйти из строя без вреда для данных в массиве)

Поскольку этапов обработки может быть несколько, на разных этапах могут достигаться (и ставиться) разные цели. Следовательно, информация обычно **неоднократно перекодируюется**.

## Представление информации

Информация в памяти ЭВМ представлена в виде цифроого двоичного кода, поскольку современные электронные элементы ПК (например, оперативная память) могут находиться только в одном из двух устойчивых состояний, которые и кодируют 0 или 1.

### Представление чисел в ЭВМ (без знака и со знаком)

Количество информации, которое может поместиться в 1 элемент памяти, называется битом. Сам по себе бит (0 или 1) мал и смысловой нагрузки не несет.

Есть примеры троичной логики, где к 0 и 1 добавляются значения неопределенности, лежащие в интервале (0,1) — см. Сетунь (СССР, 50/60-е годы XX века)

8 битов памяти образуют 1 байт памяти. Байт — минимальная **адресуемая** область памяти ЭВМ.

Адрес — порядковый номер байта.

Если соединить элементы в ячейку, которую аппаратная часть ПК (CPU в первую очередь) обрабатывает как единое целое, то мы получим **машинное слово**.

Таким образом, объем информации, представляемой в ЭВМ, ограничен емкостью памяти. А числовая информация может быть представлена только с определенной точностью, которая определяется архитектурой ПК.

Длина машинного слова может составлять 8, 16, 32, 64 (и т.д.) бита.

Адрес машинного слова = адрес его младшего байта.

Адрес — байт с меньшим порядковым номером.

00000000 FFFFFFFF FFFFFFA8 00EEFFCD
0        1        2        3

Для взаимодействия и кодирования *символьно* информации наиболее удобным для кодов в рамках 1 байта является стандартный код обмена информации ASCII (American Standard Code for Information Interchange)

КОИ-7 и КОИ-8 (советские и российские Коды Обмена Информацией для 7 и 8 бит соответственно)

Текст (КОИ-8) -> tEKST (ASCII), т.к. ставилась цель сохранить совместимость с более распространенным стандартом; даже при неправильном выборе кодировки или отсутствии КОИ-8 на ЭВМ, текст все еще можно было прочитать в виде транслитерации. При этом существуют кодировки, которые НЕ совместимы с ASCII — т.к. при их разработке ставились иные цели.

Задачка:
Микроконтроллер имеет 64 мегабайта оперативной памяти на борту. 
Адрес последнего машинного слова — 67 108 848.
Чему равен размер машинного слова на данном микроконтроллере?

Решение переводим 64 МБ в байты
 После из последнего машинного слова вычитаем то что получилось
64*1024*1024=67108864
67108848-67108864=16 байт


1кибибайт(КиБ) == 1024 байта = 2^10 байта
1мибибайт(МиБ) == 1024 кибибайта = 2^20 байта
1йобибайт(Йиб) == 2^80 Байта

