21. 
# Числа с фиксированной запятой.

Диапазон целых чисел, которые могут быть представлены в формате числа с фиксированной точкой, зависит от размера ячеек памяти, используемых для хранения целых чисел.

В **k-разрядной (битовые разряды) ячейке** может храниться `2^k` различных значений целых чисел.

Например, пусть для представления целых чисел используется 2 байта. Определить диапазон:

1. если используются только неотрицатеольные числа
2. если используются и отрицательные, и положительные числа в равном количестве.

- используется 16-битная ячейка (2 байта)
- всего в такой ячейке может храниться 2^16 различных значений — 65536 уникальных значений

Следовательно,

1. диапазон 0 — 65535 (от 0 до `2^k - 1`)
2. диапазон -32768 до +32767 (от `-2^(k-1)` до `2^(k-1) - 1`)

Пример из Аллодов

`32000 HP` -> 32000 + 768 ->  11111010 0000000 + 00000011 00000000 -> 00000000 00000001 -> `1 HP`

+ история про Ядерного Ганди (есть много где в интернете)

Представление целых чисел в памяти

В 32- и 64-битных архитектурах `int` занимает 4 байта.

k — величина в битах, отведенная для хранения данных этого типа
0...(2^k) - 1 — диапазон целого числа без знака
-(2^(k-1))...(2^k-1) - 1 — диапазон целого числа cо знаком

Для 32-битного целого числа диапазоны, например:

0...(2^32)-1 — 0 до 4 294 967 295 без знака (т.е. 0 и только положительные числа)

-(2^31)...(2^31)-1 — -2 147 483 648 до +2 147 483 647


# Представление в машинном слове компьютера и наоборот.

## внутренние представление целого положительного числа N

При условии использнования к-разрядного машинного слова ИЛИ модели данных

1. Перевести N в двоичную систему счисления.
2. Полученный результат заполнить слева незначащими нулями до получения "К" разрядов
3. Выполнить групировку разрядов по октетам(8бит)
4. Расположить октеты в соответствии с порятком байт(LE/BE).
Минимально на требуються только 2 первых шага - так получается представление числа в общем виде. Шаги 3 и 4 дают вид числа в памят конкретной машины

Пример: Представить в памяти с порядком LE и моделью данных, где для целых чисел отведено 2 байта(16 бит) десятичное число 1607 на 32 битном ЦП

1. 11001000111 - 11 разярядов в двоичном представлении числа
2. 0000011001000111 - Дополняем до 16 разрядов (11+5) нулями слева
3. 0000011001000111 разбиваем на октеты(т.е. на байты) получается ровно 2 байта как того требует модель данных
4. 01000111 00000110 - распологаем байты в соответствии с порядком 'Little-endian', как требует архитектура, т.е. располагаем младший байт (содержащий младшие разряды) **левее** всего.


Пример 2:Получить десятичное число из его шестнадцатиричного представления в памяти. известно, что для целых чисел используется 4 байта, порядок - BE

Дана следующаяя запись 0x00 0x00 0x0A 0x58

1. 00000000 00000000 00001010 01011000
2. 1010 01011000 - убрали все нули
3. 101001011000(2) = (2648)(10)


## Внутреннее представление целого отрицательного числа -N 

При условии использнования к-разрядного машинного слова ИЛИ модели данных

1. Получить внутреннее представление целого положительного числа N в тех же k разрядах(по алгоритму выше). Важно использовать для этого BE  порядок т.е. не перемещать разряды!
2. получить обратный ход числа (заменяем 1 на 0 и 0 на 1)
3. К полученному числу добавить один 
4. Разбить на октеты и разположить байты в соответствии с нужным порядком.

Пример: 1607 

0000011001000111
00000110 01000111
11111001 10111000
11111001 10111000 + 1 = 11111001 10111001


2648 в порядке LE и шестнадцатиричном виде (для хранения используються 4 байта)

00000 0000 00001010 01011000
11111111  11111111 11110101 10101000
10101000 11110101 11111111 11111111
0xA8 0xFE 0xDC 0x55

0xFF 0xFF 0xDC 0x55
11111111 11111111 11011100 01010101 -1 = 11111111 11111110 11011100 01010100
00000000 00000001 00100011 10101011(2) = -74667 (10)






# 22

# Вещественные числа. Представление в машинном слове компьютера и наоборот.


 
 В данном формате могут быть представлены и целые и дробные числа
 
Как следствие целое число в формате целого числа('int') храниться в памяти иначе, чем тоже самое число, но в формате вещественного числа.

Вещественное число R= m*n^p, где: 
R - действительное число
m - мантиса числа,
n - основание сис счисления
p - порядок(степень)

25.324 - 2.5325 * 10^1 - 2532.4 * 10^-2 = 0.0025324 * 10^4 и т.д. - точка плавает в зависимости от выбранного ими порядка

Это означает:
 
 1. Мантисса должна удволетворять условию '0.1 <= m < 1' Т.е. мантисса меньше на 1 и первая означающая цифра всегда не ноль.

 > Это выбрано для того чтобы никак не требовалось хранить в памяти 0 целых и саму точку.
 > Например: 25.324 = 0.**2532** * 10^**2**
 2. В памяти должен храниться только порядок, т.к. основание системы счисления ПК всегда 2

 Под числа с плавающей точкой отводится обычно всё машинное слово или 1/2 машинного слова. В случае с 64-битными архитектурами это означает 4 байта и 8 байтов для хранения числа с плавующей точкой

 Что и как нужно хранить:
 1. Мантиссу
 2. Порядок
 3. Знак числа
 4. Знак порядка
 
 Возьмем для примера 4 байтовое число с плавающей точкой ('float')
 [0]{0000000} 00000000 00000000 00000000
 [0] - знаковый бит, если 0 то число положительное если 1 то число отрицательное.
 {0000000} - 7 бит т.е. мы можем записать код сюда от 0(10) до 127(10) / 0000000 ..... 1111111, что удобнее для хранения порядка. **машинный порядок**

 # Понятие машинного и математического порядков.

 **Диапазон машинный порядков**
 - min машинный порядок (Mp) - 0000000(2)= 0(10)
 - max машинный порядок (Mp) - 1111111(2)= 127(10)
 **Диапазон математических порядков** = 128 шт
 Их делять на положительны
 диапазон математического порядка -64...+63
 
 Оставшиеся 3 байта(24 бита) - мантиса

## Математический и машинный порядок

Из за того что мы не можем хранить в битовом представлении отрицательный порядок, **машинный порядок смещён относительно математического и имеет только положительное значение**.

Смещение выбрано так, что минимальный математический порядок кодируется 0 в машинном порядке. Т.е. в 7 бит умещается 128 различных значений, включая 0. Чтобы представить равное число + и - математических порядков, мы делим это на 2(диапазон целых чисел)

Таким образом, мы получаем диапазон математического порядка -64...+63. Следовательно, мы можем выбирать смещение:

Mp=P+64, где Mp-машинный порядок, P- математический порядок

Так же формула в 2-й СС M(2)=P(2)+1000 000(2)
Перевод осуществляется как обычно через деление.

Смещение машинных порядков(относительно математических) в положительную область выбрана так что бы значение машинных порядков оказываються в положительной части числовой ОСИ 

# ПРИМЕР!!!

Используем 32 битный тип данных для записи чисел с плавающей точкой.
 
 1. Переводим *модуль* числа в двоичную СС с [24] значищими цифрами, дополняем нулями справо до 24 разрядов.
 2. Нормализовать двоичное число(см. формулу выше;0.1 <= m < 1)
 3. Найти машинный порядок по формуле M(2)=P(2)+1000 000(2)
 4. Учитывая исходный знак числа (т.е. корректно выставить значения знакового бита), вписать результат(машинный порядок и мантисса) в доступные 4 байта (или машинное слово)

Пример: Записать представление числа **250.1875**

 250.1875(10)-->11111010.0011(2)
 После добовляем до 24 цифр
 11111010.00110000 00000000
 0.111110100011000000000000(2)*10(2)^1000(2)
 *порядок P = числу разрядов в целой части числа* *1000(2)=8(10)*
 1001000(2)-машинный порядок

 [0]{1001000}11111010 00110000 00000000 -  Машинное представление числа 250.1875(10)

0xC9 0x81 0x10 0x00

11001001 10000001 00010000 00000000
[1]{1001001} 10000001 00010000 00000000 
M(2)=1001001=> P(2)= 1001(2) = 9(10)
10000001 00010000 00000000*10^1001(2)
100000010.001(2) - переводим в (10)
100000010.001 = -258.125(10)

# 23

# Измерение информации
 Алфавитный подход является `объяктивным` т.к. не зависит от субъекта (человека, воспринимающего текст)

Например:
Мы считаем кол во информации которая содержиться в некоторой книге.
Книга - 150 стр, 40 строк, 80 символов в строке.

Предположим что **мощность алфавита** 256. Каждый символ занимает 1 байт

1 страница - 3200 символов
Всего символов - 480 000
480 000 * 8бит = 3 840 000 бит информации

# Формула Хартли

**Алфавит** множество символов которыми кодируется сообщениями. 
**Мощность алфавита** - Число символов в алфавите
Формула Хартли определяет кол-во информации в сообщениях 
**I - K *log2(N)**
N- Мощность алфавита k- длина сообщения I кол во инфы в битах

Из этого следует N- 2^i  Где i - информационный вес 1 символа алфавита

*i = log2(N)* кол во информации в битах в 1 символе алфавита мощьность N

Формула Хартли является частным случаем формулы Шенной для равновероятных событий.

# формула шеннона

Формула Шеннона для определения колва информации в 1 событии, когда события не являються равновероятными.

`I = -log2(p) - log2(1/p)` где p - вероятность наступления следующего события

Из этого следует что чем ниже вероятность наступления события, тем больше информации ма получим.

Пример 
В коробке 50 шаров
40 из них красные
10 - зелёные
P(к) - 40/50 = 0.8
Р(з) = 10/50 = 0.2

В 4 раза выше вытащить красный шар

I(к)= log2(1/0.8) - 0.32 бита инфы

I(з) = log2(1/0.2) - 2.32 бита инфы

I(кзккк) = 3.6 бита


# Про вероятность 
Формула Хартли является частным случаем формулы Шенной для равновероятных событий.

Формула Шеннона для определения колва информации в 1 событии, когда события не являються равновероятными.