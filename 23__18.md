# Рекурсия и ее применения в алгоритмах

**Рекурсия** — процесс повторения элемента внутри этого же элемента.

> Под элементом в программировании чаще всего понимается тело некоторой функции или цикла.

Рекурсия активно используется в комбинаторике.

Алгоритм считается *рекурсивным*, если удовлетворяет следующим критериям:

1. В нем присутствует одно или более условие **выхода** из рекурсии.
2. В алгоритме определен **шаг** рекурсии, который в конечном итоге должен привести к одному или нескольким условиям выхода.

> Любой рекурсивный алгоритм *может* быть переписан **без использования рекурсии**.

```c++
void foo(int num)
{
    if (num > 0)  // условие выхода из рекурсии
    {
        // шаг рекурсии
        cout << num-- << endl;
        foo(num);  // рекурсивный вызов — функция вызывает себя из себя
    }
}
```

Важным параметром является **глубина рекурсии** — количество вложенных вызовов, т.е. на сколько уровней «вглубь» ваш алгоритм уходит на каждом шаге рекурсии.

Пример того, когда мы очень быстро можем уйти «на глубину» — вычисление рекурсивно факториала положительного числа (n!) без оптимизаций и кэширования.

## Почему использовать рекурсию?

1. Если при анализе (декомпозиции) задачи (процесса) вы выявляете, что алгоритм решения задачи или процесс по своей сути рекурсивны, рекурсивная реализация будет чище и нагляднее с точки зрения синтаксиса языка программирования.
2. Если вы работаете в декларативной парадигме (в т.ч. функциональной), рекурсия становится основной операцией, заменяющей цикл — см. примеры в Haskell, Prolog/Datalog.

В иных случаях необходимо оценивать риски использования рекурсии в части большой глубины рекурсии (что ведет к нехватке памяти и/или большому времени выполнения алгоритма) или потенциальном риске бесконечной рекурсии (заданы ненадежные условия выхода из рекурсии).

## Виды рекурсии

### 1. Простая рекурсия

Простая рекурсия — вызов элемента самим собой. Пример — все то же рекурсивное вычисление факториала. Количество вложенных вызовов называется глубиной рекурсии. Пример см. выше.

### 2. Сложная рекурсия

Сложная рекурсия — когда элемент 1 вызывает элемент 2, а тот вызывает элемент 1. Цепочка может быть и длиннее, но всегда должна заканчиваться вызовом самого первого элемента.

> Важно! В C++ для таких алгоритмов обязательно нужно использовать прототипы функций, иначе вызов второй функции из первой приведет к ошибке (т.к. она еще не будет определена)

### 3. Хвостовая рекурсия

Tail Recursion.

Частный случай рекурсии, при котором любой рекурсивный вызов является последней операцией перед возвратом (`return`) из функции.

```cpp
void foo(int num)
{
    if (num <= 0) return;
    cout << num-- << endl;

    foo(num);
}
```

![пример хвостовой](https://www.baeldung.com/wp-content/ql-cache/quicklatex.com-e89d58152bb1cc1a0225b88fc6f5bedc_l3.svg)

```cpp
int tailSum(int x)
{
    if (x == 0) return 0;

    return x + tailSum(x-1);
}
```

tailSum(4)
    4 + tailSum(3)
        3 + tailSum(2)
            2 + tailSum(1)
                1 + tailSum(0)
                1 + 0
            2 + 1
        3 + 3
    4 + 6
10

# Список лабораторных работ к следующей неделе

1. Двумерный массив — заполнение в шахматном порядке
2. Двумерный массив (матрица) — выше главной диагонали 0, главная диагональ и ниже — цифры по шаблону
3. Рекурсии
    - сумма членов ряда
    - числа Фибоначчи (функция, принимающая n, где n — порядковый номер нужного числа Фибоначчи)
    - Ханойские башни
    - задача о расстановке 8 ферзей
4. Лаб. работа №4 из зеленой методички
5. Лаб. работа №5 из зеленой методички

## Сумма ряда

Приближенно вычислить значение функции двумя способами:

1) Через сумму функционального ряда с помощью рекурсивной функции. Аргументы функции — n и x, где n — количество членов ряда, x — переменная. 
2) Через прямое вычисление значения функции. Аргумент функции — переменная x.

Сравнить полученные результаты

## Задача о расстановке 8 ферзей

На стандартной шахматной доске 8х8 необходимо разместить 8 ферзей так, чтобы ни один из них не был под ударом другого.

Ферзь бьет все клетки по вертикалям, горизонталям и обеим диагоналям.

Первый ферзь ставится случайно.
