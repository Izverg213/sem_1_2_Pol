# Модели данных 
Модель данных - [соглашение] В рамках которого конкретная реализация компилятора (интепритатора) языка програмирования определяет размер(в байтах/битах) фундоминтальных(Базовых) типов данных.

Модель данных может кодироваться 3-мя значениями
- размером целого числа (`Int`)
- размером длинного целого (`Long Int`)
- размером указателя (`prt`) в байтах.

## 32-битные модели

Максимальное ограничение адресеного пространства в 32-битных моделях равно 4 ГБ.

### LP32 (2/4/4)
Расшифровка названия - Long pointer -32
Использовалась на 32 битных системах приемущественно в Win16 API.

### ILP32 (4/4/4)
расшифровка - Integer, long, pointer 32.
Win 32 API
Unix и подобные системы 

## 64 - битные 

### LLP64 (4/4/8)

Расшифровка - int, long 32, pointer 64
Используется в Win64 API

### LP64 (4/8/8)

int-32 long-64 pointer-64

Используют 64-битные Unix и подобные системы
(Linux и macOS)

## Размеры в битах для разных моделей данных и типов данных

`Вставить табличку`
| Тип данных                                 | Стандарт C++ | LP32 | ILP32 | LLP64 | LP64 |
| ----------                                 | ------------ | ---- | ----- | ----- | ---- |
| указатель (pointer)                        | не менее 32  | 32   | 32    | 64    | 64   |
| короткое целое (short int)                 | не менее 16  | 16   | 16    | 16    | 16   |
| целое (int)                                | не менее 16  | 16   | 32    | 32    | 32   |
| длинное целое (long int)                   | не менее 32  | 32   | 32    | 32    | 64   |
| длинное длинное целое (long long int)      | не менее 64  | 64   | 64    | 64    | 64   |
| плавающая точка одинарной точности (float) | не менее 32  | 32   | 32    | 32    | 32   |
| плавающая точка двойной точности (double)  | не менее 64  | 64   | 64    | 64    | 64   |

Реализации float и double подчиняется стандарту IEEE 754.  

**для float**
* Знаковый бит:1
* Порядок 8
* Мантисса 23 (вычесляется до 24 знака, последний бит явно не хранится)

**Для double**
* знаковый бит:1
* порядок: 11
* Мантисса: 52 

#  Алфавитный подход к измерению информации.

Алфавитный подход является `объяктивным` т.к. не зависит от субъекта (человека, воспринимающего текст)

Например:
Мы считаем кол во информации которая содержиться в некоторой книге.
Книга - 150 стр, 40 строк, 80 символов в строке.

Предположим что **мощность алфавита** 256. Каждый символ занимает 1 байт

1 страница - 3200 символов
Всего символов - 480 000
480 000 * 8бит = 3 840 000 бит информации

## Формула Хартли и формула Шеннона
**Алфавит** множество символов которыми кодируется сообщениями. 
**Мощность алфавита** - Число символов в алфавите
Формула Хартли определяет кол-во информации в сообщениях 
**I - K *log2(N)**
N- Мощность алфавита k- длина сообщения I кол во инфы в битах

Из этого следует N- 2^i  Где i - информационный вес 1 символа алфавита

*i = log2(N)* кол во информации в битах в 1 символе алфавита мощьность N

Формула Хартли является частным случаем формулы Шенной для равновероятных событий.

Формула Шеннона для определения колва информации в 1 событии, когда события не являються равновероятными.

`I = -log2(p) - log2(1/p)` где p - вероятность наступления следующего события

Из этого следует что чем ниже вероятность наступления события, тем больше информации ма получим.

Пример 
В коробке 50 шаров
40 из них красные
10 - зелёные
P(к) - 40/50 = 0.8
Р(з) = 10/50 = 0.2

В 4 раза выше вытащить красный шар

I(к)= log2(1/0.8) - 0.32 бита инфы

I(з) = log2(1/0.2) - 2.32 бита инфы

I(кзккк) = 3.6 бита

Имеется шифрованный алфавит, содержит в себе следующие символы
А - известно что шифровка содержит 4000
Y - 1000
M - 2000
K - 1500
. - 500
_ - 1000
Расчитать количество информации в шифровке.

Всего в шифровке 10000 (N — общее число исходов)

P(А) = 4000 / 10000 = 0,4
i(А) = log2(1/0,4) = 1.3219...

P(У) = 1000 / 10000 = 0,1
i(У) = log2(1/0,1) = 3.3219...

P(М) = 2000 / 10000 = 0,2
i(М) = log2(1/0,2) = 2.3219...

P(К) = 1500 / 10000 = 0,15
i(К) = log2(1/0,15) = 2.7369...

P(.) = 500 / 10000 = 0,05
i(.) = log2(1/0,05) = 4.3219...

P(_) = 1000 / 10000 = 0,1
i(_) = log2(1/0,1) = 3.3219...

Рассчитваем объем информации в шифровке

`I = i(А) * n(А) + i(У) * n(У) + i(М) * n(М) + i(К) * n(К) + i(.) * n(.) + i(_) * n(_) = 5280 + 2* 3320 + 4640 + 2160 + 4095 = ~22815 бит`

В коробке лежат видеокарты AMD и NVIDIA. Среди них 18 NVIDIA. Сообщение о том, что из коробки достали AMD, несет 2 бита информации.

Сколько всего карт в коробке? — 24 штуки (по Шеннону)

Вычислить кол-во информации, получаемой при броске игральных костей (число после d обозначает число граней на кости, вероятность выпадения каждой грани на 1 кости одинакова; число перед d — сколько костей бросается)

1. 1d20 `i = log2(20) = 4.32`
2. 1d6 `i = log2(6) = 2.58`
3. 2d6 (одновременном) `2*2.58 = 5.16`

# Основы математической логики

В логических бинарных операциях высказывания могут быть истинными (True, 1) или ложными (False, 0).

## 1. Отрицание !A (¬A, ~A), NOT

Отрицание — унарная операция, в ней используется только 1 операнд.

| A | !A |
| - | -- |
| 0 | 1  |
| 1 | 0  |

## 2. Конъюнкция (логическое И, логическое умножение): A && B (A∧B), AND

1 — тогда и только тогда, когда **на всех** входах 1. 0 — если хотя бы на 1 входе 0.

Конъюнкция может быть бинарной, тернарной и т.д., т.е. она может быть n-арной операцией (иметь n операндов).

| A | B | A && B
| - | - | ------
| 0 | 0 | 0
| 0 | 1 | 0
| 1 | 0 | 0
| 1 | 1 | 1

## 3. Дизъюнкция (логическое ИЛИ, логическое сложение): A || B (A∨B), OR

1 — если хотя бы на 1 входе 1. 0 — тогда и только тогда, когда на всех входах 0.

Дизъюнкция может быть бинарной, тернарной и т.д., т.е. она может быть n-арной операцией (иметь n операндов).

| A | B | A || B
| - | - | ------
| 0 | 0 | 0
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 1

## 4. Импликация


Имплекация ложна только тогда когда посылка истина а посылка ложна

Бинарная логическая связка, приближенная к выражению «если..., то...».

Записывается она как
`посылка` ⇒ `следствие`

Например:

A — преподаватель, B — студент

Преподаватель может сказать студенту: «решай задачу» (1) или он может сказать: «занимайся, чем хочешь» (0).

Студент может решить задачу (1) или ничего не делать (0).

Импликация ложна тогда и только тогда, когда посылка истинна, а следствие ложно.

| A | B | A ⇒ B
| - | - | ------
| 0 | 0 | 1
| 0 | 1 | 1
| 1 | 0 | 0
| 1 | 1 | 1

Следовательно, выражение A ⇒ B можно записать как ¬A ∨ B

## 5. Эквивалентность (эквиваленция, логическая равнозначность, исключающее ИЛИ с инверсией, XNOR)

Логическое выражение, которое истинно тогда и только тогда, когда оба простых выражения имеют одинаковую истинность.

A ≡ B или A ↔ B

| A | B | A ↔ B
| - | - | ------
| 0 | 0 | 1
| 0 | 1 | 0
| 1 | 0 | 0
| 1 | 1 | 1

Можно заменить (¬A ∧ ¬B) ∨ (A ∧ B).

## 6. Строгая дизъюнкция (исключающее ИЛИ, сложение по модулю 2, жегалкинское сложение): A ^ B, XOR

| A | B | A ^ B
| - | - | ------
| 0 | 0 | 0
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 0

## 7. Штриx Шеффера (отрицание конъюнкции, операция И-НЕ, NAND): A | B, в C++ реализации прямой нет!

A | B означает, что A и B несовместны, т.е. они никогда не являются истинными одновременно. При этом результат не поменяется от перемены мест операндов.

| A | B | A | B
| - | - | ------
| 0 | 0 | 1
| 0 | 1 | 1
| 1 | 0 | 1
| 1 | 1 | 0

## 8. Стрелка Пирса (функция Вебба, отрицание дизъюнкции, операция ИЛИ-НЕ, NOR, конъюнкция отрицаний)

Выражение A ↓ B ознает, что только в случае ложности обоих операндов высказывание будет истинным, что аналогично (!A && !B)

| A | B | A ↓ B
| - | - | ------
| 0 | 0 | 1
| 0 | 1 | 0
| 1 | 0 | 0
| 1 | 1 | 0




